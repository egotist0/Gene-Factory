# python大作业：Gene comparison

姜戈519111910306

生物信息与统计学系



## 一.课题灵感

这个项目的灵感来自于本学期的一门专业课计算编程语言，老师在讲动态规划算法时提出的可以用于序列比对算出最优得分，这就引出了一个问题：序列比对

序列比对：是为确定两个或多个序列之间的相似性以至于同源性，而将它们按照一定的规律排列。将两个或多个序列排列在一起，标明其相似之处。序列中可以插入间隔（通常用短横线“-”表示）。

这一方法常用于研究由共同祖先进化而来的序列，特别是如蛋白质序列或DNA序列等生物序列。在比对中，错配与突变相应，而空位与插入或缺失对应。序列比对还可用于语言进化或文本间相似性之类的研究。

基于这个问题，我采用了Needleman/Wunsch算法（一个专用于文本比对的算法），来解决序列比对的评分问题和最佳回溯结果，然后衍生出了一些小功能，比如随机序列生成和数据分析等，从使用方便性考虑我用tinker包设计了一个可视化的小程序，整个程序是在python3.8的anaconda3环境下进行的



## 二.主要功能及简要介绍

大致可以分成3个

### 1.序列比对与最佳回溯结果

#### 思路

在生物信息处理中，我们希望找出两条序列之间具有的某种相似性关系，这种寻找生物序列相似性关系的算法就是双序列比对算法 。通常利用两个序列之间的字符差异来测定序列之间的相似性，两条序列中相应位置的字符如果差异大，那么序列的相似性低，反之，序列的相似性就高。

- 生物碱基序列由ATCG组成，进行比对时需要设定一个评分的规则，我这里设定的是`match=5,dismatch=-4,gap=-2.5`,如果使用者需要可以自己修改规则，修改规则的位置在`data_analysis.py`文件的26-28行和`dp.py`文件的16-18行：![](file:///home/egotist/PycharmProjects/dp_program/photo/1.jpg)

![](file:///home/egotist/PycharmProjects/dp_program/photo/2.jpg)

具体的算法实现思路是动态规划

#### 评分函数

+ `gap`表示缺失得分为2.5，`m`表示匹配得分为5，`mm`表示非匹配得分设为-4；

+ 初始化数组，对于第0层，第0列赋值为`i*gap`;

+ 下面的双层`for`循环是对二维数组的每个位置算`score`值：

  1. 总体每个位点的得分为：

     **三个方向的得分=该方向上一位点得分+移动过程得分**

     最后选取三个方向最高得分作为该位点的得分，以此循环从上到下，从左到右得到整个矩阵的得分。

  2. 然后经过上一步就知道**最右下角的得分肯定是最优得分，因为它是从每种子情况的最优得分得到的。**

  3. 具体的操作就是

     1. 如果`str1[i - 1] = str2[j - 1]`,那么`score[i，j]`直接等于`score[i-1，j-1]+m`
     2. 如果`str1[i - 1] != str2[j - 1]`,那么`score[i，j]`直接等于`score[i-1，j-1]+mm`
     3. 先进行上面两步，然后左上角`score[i，j-1]`与右上角`score[i-1，j]`比较取出较大值，然后得出来的较大值加上`gap`,如果此时`score[i，j]`小于这个新的得到的分数，那么更新`score[i，j]`,否则则不更新；
     4. 最后的结果就是选取三个方向最高得分作为该位点的得分；

+ 完整的分数表格形成后最右下角的得分必然就是最佳匹配得分，写入`SCORE`文件即可；同时返回给小程序

+ 但是我们还需要知道它是从哪一条路径得到的这个最优得分。因此需要回溯，这里就调用了`printAlign`函数

#### 回溯函数

+ 回溯的方式就是看每个回溯位点的左上方，上方和左方最大值位置，最后就可以得到整个回溯路径；

+ `printAlign`函数输入的参数比较多，`score`是输入的二维评分数组，`i`和`j`表示的是此时回溯到的评分数组的位置，初始位置就是从(len1,len2)开始，`s1`和`s2`是进行的回溯的两条序列，`saln`和`raln`存储的是最后输出的最佳匹配结果

+ 三个`if`判断是是判断左上，左，上哪个得分最高，最高的就是最优的匹配路径：

  1. 从右下方开始，如果最大值出现在上面，则横向这条序列引入一个GAP ("-")，纵向这条序列取该处碱基；
  2. 如果最大值出现在左边，则纵向这条序列引入一个GAP ("-")，横向这条序列取该处碱基; 
  3. 如果最大值出现在左上角，则不引入GAP，纵向和横向均取该处碱基。
  4. 当然这个回溯的路径不一定唯一，当三个位置有两个相同的时候，两个路径都是可行的,但为了小程序输出方便，我用了`if...elif`这样就只会筛出一个序列输出

#### 使用手册

运行`smallprogram.py`文件，首先打开`On`，然后输入两条序列，点击上方按钮即可输出最高得分和最佳匹配方式

![](file:///home/egotist/PycharmProjects/dp_program/photo/%E5%88%9D%E5%A7%8B.jpg)

![](file:///home/egotist/PycharmProjects/dp_program/photo/3.png)

**由于这是一个优秀的文本字符串比对算法，因此不仅可以用来比对碱基序列，类似的文本比对，相似度比对，文字查重，蛋白质序列比对都可以同样进行**



### 2.生成比例为人类染色体的随机序列

#### 思路

人类1号染色体拥有2.3亿个碱基序列，人的很多模拟实验都要用到这些序列来研究特定排序的表达效果和功能，这时候不一定要从NCBI数据库下载真实的数据而只需要类似比例的序列进行模拟处理即可；

所以我就想到了这样一个小功能来帮助研究人员生成特定长度的特定数量的符合人类染色体一行碱基比例的DNA序列

#### getseqs函数

函数具体的实现思路很简单

```python
from random import *
pairwise = "AAATTTCCGG"
def getseq(num):
    seq = []
    for i in range(num):
        seq.append(pairwise[randint(0, 9)])
    return seq
```

因为查阅文献可以知道，一号染色体的AT与CG比例为3：2，所以我静态定义了一个字符串`pairwise`，其中的AT与CG比例正好符合要求，然后用生成随机数的方式从这个字符串里取出元素整合到新生成的序列中，然后执行这个函数规定次数，将所有生成的序列按行写入一个文件`seqs.txt`中

#### 使用手册

运行`smallprogram.py`文件，首先打开`On`，然后输入要求的长度和数量，点击上方按钮即可输出第一条符合要求的序列，然后在文件夹中的`seqs.txt`文件中即可找到其他所有满足该要求的序列

![](file:///home/egotist/PycharmProjects/dp_program/photo/4.jpg)

![](file:///home/egotist/PycharmProjects/dp_program/photo/5.jpg)

**如果想要生成特定比例的序列只需修改原文件中的`pairwise`字符串的AT与CG比例即可**

### 3.验证score服从的分布以及数据特征

#### 思路

这个是专业课的一个作业题，生成50条比例符合人类染色体1号序列的序列，然后任一两条之间进行比对生成score文件存储最终得分和seq文件存放最佳比对结果。

然后对于score文件绘制直方图判断其是否服从高斯分布，并计算score的平均值，标准差和进行k-s检验的结果



#### 具体实现

具体的实现函数和序列比对类似，只是多了`loadDta`函数读取`score.txt`文件并进行数据处理，`draw_hist`函数绘制直方图并存为`outcome.png`,然后将数据处理的结果全部输出到`outcome.txt`文件，并输出k-s检验的结果到软件中



#### 使用手册

运行`smallprogram.py`文件，首先打开`On`，然后点击中间上方按钮即可输出k-s检验结果，然后在文件夹中的`seq.txt,score.txt,outcome.txt,outcome.png`中可以查看详细结果

![](file:///home/egotist/PycharmProjects/dp_program/photo/6.jpg)

![](file:///home/egotist/PycharmProjects/dp_program/photo/9.jpg)

![](file:///home/egotist/PycharmProjects/dp_program/photo/10.jpg)

![](/home/egotist/PycharmProjects/dp_program/photo/7.jpg)





## 三.总结

实现的几个小功能其实都还比较简单，写起来没有啥问题.GUI编程对于所使用的包还不太熟悉，数据分析这一块还可以做很多东西，后续会逐渐补齐这一部分功能。

`tinker`包做这种可视化界面感觉终究是有一些麻烦的，并且美观性和功能性还有所欠缺，后续我会用`django`做一个网页的实现，然后加入更多使用的功能逐步完善这个小程序。

代码文件已上传至作者的github（egotist0），可以在里面获得实现文件，如果感兴趣或想提出一些建议的话,可以给本人的 Github 留言或直接参与修改